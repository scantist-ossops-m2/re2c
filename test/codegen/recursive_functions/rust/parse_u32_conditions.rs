/* Generated by re2c */
// re2rust $INPUT -o $OUTPUT -c --recursive-functions
#![allow(non_snake_case)]

const YYC_INIT: usize = 1;
const YYC_BIN: usize = 11;
const YYC_OCT: usize = 14;
const YYC_DEC: usize = 17;
const YYC_HEX: usize = 20;


const ERROR: u64 = std::u32::MAX as u64 + 1; // overflow

// Add digit with the given base, checking for overflow.
fn add(st: &mut State, offs: u8, base: u64) {
    let digit = unsafe { st.str.get_unchecked(st.cur - 1) } - offs;
    st.num = std::cmp::min(st.num * base + digit as u64, ERROR);
}

fn parse_u32(s: & [u8]) -> Option<u32> {
    let mut st = State {str: s, cur: 0, mar: 0, cond: YYC_INIT, num: 0};
    parse_start(&mut st)
}

// Store u32 number in u64 during parsing to simplify overflow hadling.
struct State<'a> {
    str: &'a [u8],
    cur: usize,
    mar: usize,
    cond: usize,
    num: u64,
}


fn yy1(_st: &mut State) -> Option<u32> {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	_st.cur += 1;
	match yych {
		0x30 => yy3(_st),
		0x31 ..= 0x39 => yy5(_st),
		_ => yy2(_st),
	}
}

fn yy2(_st: &mut State) -> Option<u32> {
	return None;
}

fn yy3(_st: &mut State) -> Option<u32> {
	_st.mar = _st.cur;
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	match yych {
		0x42 |
		0x62 => {
			_st.cur += 1;
			yy6(_st)
		}
		0x58 |
		0x78 => {
			_st.cur += 1;
			yy8(_st)
		}
		_ => yy4(_st),
	}
}

fn yy4(_st: &mut State) -> Option<u32> {
	_st.cond = YYC_OCT;
	yyfnOCT(_st)
}

fn yy5(_st: &mut State) -> Option<u32> {
	_st.cur = (_st.cur as isize + -1) as usize;
	_st.cond = YYC_DEC;
	yyfnDEC(_st)
}

fn yy6(_st: &mut State) -> Option<u32> {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	match yych {
		0x30 ..= 0x31 => {
			_st.cur += 1;
			yy9(_st)
		}
		_ => yy7(_st),
	}
}

fn yy7(_st: &mut State) -> Option<u32> {
	_st.cur = _st.mar;
	yy4(_st)
}

fn yy8(_st: &mut State) -> Option<u32> {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	match yych {
		0x30 ..= 0x39 |
		0x41 ..= 0x46 |
		0x61 ..= 0x66 => {
			_st.cur += 1;
			yy10(_st)
		}
		_ => yy7(_st),
	}
}

fn yy9(_st: &mut State) -> Option<u32> {
	_st.cur = (_st.cur as isize + -1) as usize;
	_st.cond = YYC_BIN;
	yyfnBIN(_st)
}

fn yy10(_st: &mut State) -> Option<u32> {
	_st.cur = (_st.cur as isize + -1) as usize;
	_st.cond = YYC_HEX;
	yyfnHEX(_st)
}

fn yyfnINIT(_st: &mut State) -> Option<u32> {
	yy1(_st)
}

fn yy11(_st: &mut State) -> Option<u32> {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	_st.cur += 1;
	match yych {
		0x30 ..= 0x31 => yy13(_st),
		_ => yy12(_st),
	}
}

fn yy12(_st: &mut State) -> Option<u32> {
	
        return if _st.num < ERROR { Some(_st.num as u32) } else { None };

}

fn yy13(_st: &mut State) -> Option<u32> {
	add(_st, 48, 2);  return yyfnBIN(_st);
}

fn yyfnBIN(_st: &mut State) -> Option<u32> {
	yy11(_st)
}

fn yy14(_st: &mut State) -> Option<u32> {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	_st.cur += 1;
	match yych {
		0x30 ..= 0x37 => yy16(_st),
		_ => yy15(_st),
	}
}

fn yy15(_st: &mut State) -> Option<u32> {
	
        return if _st.num < ERROR { Some(_st.num as u32) } else { None };

}

fn yy16(_st: &mut State) -> Option<u32> {
	add(_st, 48, 8);  return yyfnOCT(_st);
}

fn yyfnOCT(_st: &mut State) -> Option<u32> {
	yy14(_st)
}

fn yy17(_st: &mut State) -> Option<u32> {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	_st.cur += 1;
	match yych {
		0x30 ..= 0x39 => yy19(_st),
		_ => yy18(_st),
	}
}

fn yy18(_st: &mut State) -> Option<u32> {
	
        return if _st.num < ERROR { Some(_st.num as u32) } else { None };

}

fn yy19(_st: &mut State) -> Option<u32> {
	add(_st, 48, 10); return yyfnDEC(_st);
}

fn yyfnDEC(_st: &mut State) -> Option<u32> {
	yy17(_st)
}

fn yy20(_st: &mut State) -> Option<u32> {
	let yych = unsafe {*_st.str.get_unchecked(_st.cur)};
	_st.cur += 1;
	match yych {
		0x30 ..= 0x39 => yy22(_st),
		0x41 ..= 0x46 => yy23(_st),
		0x61 ..= 0x66 => yy24(_st),
		_ => yy21(_st),
	}
}

fn yy21(_st: &mut State) -> Option<u32> {
	
        return if _st.num < ERROR { Some(_st.num as u32) } else { None };

}

fn yy22(_st: &mut State) -> Option<u32> {
	add(_st, 48, 16); return yyfnHEX(_st);
}

fn yy23(_st: &mut State) -> Option<u32> {
	add(_st, 55, 16); return yyfnHEX(_st);
}

fn yy24(_st: &mut State) -> Option<u32> {
	add(_st, 87, 16); return yyfnHEX(_st);
}

fn yyfnHEX(_st: &mut State) -> Option<u32> {
	yy20(_st)
}

fn yy0(_st: &mut State) -> Option<u32> {
	match _st.cond {
		YYC_INIT => yyfnINIT(_st),
		YYC_BIN => yyfnBIN(_st),
		YYC_OCT => yyfnOCT(_st),
		YYC_DEC => yyfnDEC(_st),
		YYC_HEX => yyfnHEX(_st),
		_ => panic!("internal lexer error"),
	}
}

fn parse_start(_st: &mut State) -> Option<u32> {
	yy0(_st)
}



fn main() {
    assert_eq!(parse_u32(b"\0"), None);
    assert_eq!(parse_u32(b"1234567890\0"), Some(1234567890));
    assert_eq!(parse_u32(b"0b1101\0"), Some(13));
    assert_eq!(parse_u32(b"0x7Fe\0"), Some(2046));
    assert_eq!(parse_u32(b"0644\0"), Some(420));
    assert_eq!(parse_u32(b"9999999999\0"), None);
}
